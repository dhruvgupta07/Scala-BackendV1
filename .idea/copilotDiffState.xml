<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/main/scala/com/example/Main.scala">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/scala/com/example/Main.scala" />
              <option name="originalContent" value="package com.example&#10;&#10;import akka.actor.typed.ActorSystem&#10;import akka.actor.typed.scaladsl.Behaviors&#10;import akka.http.scaladsl.Http&#10;import akka.http.scaladsl.server.Directives._&#10;import com.routes.UserRoutes&#10;import com.services.UserServices&#10;import scala.concurrent.{ExecutionContext, Future, Promise, Await}&#10;import scala.util.{Failure, Success}&#10;import scala.concurrent.duration._&#10;import akka.Done&#10;&#10;object Main extends App {&#10;  implicit val system: ActorSystem[Nothing] = ActorSystem(&#10;    Behaviors.empty,&#10;    &quot;user-management-system&quot;&#10;  )&#10;  implicit val executionContext: ExecutionContext = system.executionContext&#10;&#10;  val userService = new UserServices(executionContext)&#10;  val userRoutes = new UserRoutes(userService)&#10;&#10;  val routes = concat(&#10;    userRoutes.routes,&#10;    userRoutes.healthRoutes,&#10;    pathSingleSlash {&#10;      get {&#10;        complete(&quot;Welcome to User Management API! Try /api/users or /health&quot;)&#10;      }&#10;    }&#10;  )&#10;&#10;  val bindingFuture = Http()&#10;    .newServerAt(&quot;0.0.0.0&quot;, 8080)&#10;    .bind(routes)&#10;&#10;  bindingFuture.onComplete {&#10;    case Success(binding) =&gt;&#10;      val address = binding.localAddress&#10;      system.log.info(&quot; Server online at http://{}:{}/&quot;, address.getHostString, address.getPort)&#10;      system.log.info(&quot; Available endpoints:&quot;)&#10;      system.log.info(&quot;  GET    /health&quot;)&#10;      system.log.info(&quot;  GET    /api/users&quot;)&#10;      system.log.info(&quot;  POST   /api/users&quot;)&#10;      system.log.info(&quot;  GET    /api/users/{{id}}&quot;)&#10;      system.log.info(&quot;  PUT    /api/users/{{id}}&quot;)&#10;      system.log.info(&quot;  DELETE /api/users/{{id}}&quot;)&#10;&#10;      Runtime.getRuntime.addShutdownHook(new Thread(() =&gt; {&#10;        system.log.info(&quot; Received shutdown signal. Starting graceful shutdown...&quot;)&#10;        val shutdownF = binding.terminate(30.seconds).flatMap { _ =&gt;&#10;          system.log.info(&quot;✅ Server shutdown completed&quot;)&#10;          system.whenTerminated&#10;        }&#10;        Await.result(shutdownF, 40.seconds)&#10;      }))&#10;&#10;    case Failure(ex) =&gt;&#10;      system.log.error(&quot;Failed to bind HTTP endpoint, terminating system&quot;, ex)&#10;      system.whenTerminated&#10;  }&#10;&#10;  // Keep the application running indefinitely&#10;  Await.result(system.whenTerminated, Duration.Inf)&#10;}&#10;" />
              <option name="updatedContent" value="package com.example&#10;&#10;import akka.actor.typed.ActorSystem&#10;import akka.actor.typed.scaladsl.Behaviors&#10;import akka.http.scaladsl.Http&#10;import akka.http.scaladsl.server.Directives._&#10;import com.routes.UserRoutes&#10;import com.services.UserServices&#10;import scala.concurrent.{ExecutionContext, Future, Promise, Await}&#10;import scala.util.{Failure, Success}&#10;import scala.concurrent.duration._&#10;import akka.Done&#10;&#10;object Main extends App {&#10;  implicit val system: ActorSystem[Nothing] = ActorSystem(&#10;    Behaviors.empty,&#10;    &quot;user-management-system&quot;&#10;  )&#10;  implicit val executionContext: ExecutionContext = system.executionContext&#10;&#10;  val userService = new UserServices(executionContext)&#10;  val userRoutes = new UserRoutes(userService)&#10;&#10;  val routes = concat(&#10;    userRoutes.routes,&#10;    userRoutes.healthRoutes,&#10;    pathSingleSlash {&#10;      get {&#10;        complete(&quot;Welcome to User Management API! Try /api/users or /health&quot;)&#10;      }&#10;    }&#10;  )&#10;&#10;  val bindingFuture = Http()&#10;    .newServerAt(&quot;0.0.0.0&quot;, 8080)&#10;    .bind(routes)&#10;&#10;  bindingFuture.onComplete {&#10;    case Success(binding) =&gt;&#10;      val address = binding.localAddress&#10;      system.log.info(&quot; Server online at http://{}:{}/&quot;, address.getHostString, address.getPort)&#10;      system.log.info(&quot; Available endpoints:&quot;)&#10;      system.log.info(&quot;  GET    /health&quot;)&#10;      system.log.info(&quot;  GET    /api/users&quot;)&#10;      system.log.info(&quot;  POST   /api/users&quot;)&#10;      system.log.info(&quot;  GET    /api/users/{{id}}&quot;)&#10;      system.log.info(&quot;  PUT    /api/users/{{id}}&quot;)&#10;      system.log.info(&quot;  DELETE /api/users/{{id}}&quot;)&#10;&#10;      Runtime.getRuntime.addShutdownHook(new Thread(() =&gt; {&#10;        system.log.info(&quot; Received shutdown signal. Starting graceful shutdown...&quot;)&#10;        try {&#10;          val shutdownF = binding.terminate(30.seconds).flatMap { _ =&gt;&#10;            system.log.info(&quot;✅ Server shutdown completed&quot;)&#10;            system.whenTerminated&#10;          }&#10;          Await.result(shutdownF, 40.seconds)&#10;        } catch {&#10;          case ex: Throwable =&gt;&#10;            system.log.error(&quot;❌ Error during shutdown: {}&quot;, ex.getMessage)&#10;            system.terminate()&#10;        }&#10;      }))&#10;&#10;    case Failure(ex) =&gt;&#10;      system.log.error(&quot;❌ Failed to bind HTTP endpoint, terminating system: {}&quot;, ex.getMessage)&#10;      system.terminate()&#10;      System.exit(1)  // Ensure container restarts on binding failure&#10;  }&#10;&#10;  // Keep the application running indefinitely&#10;  try {&#10;    Await.result(system.whenTerminated, Duration.Inf)&#10;  } catch {&#10;    case ex: Throwable =&gt;&#10;      system.log.error(&quot;❌ Fatal error, system terminating: {}&quot;, ex.getMessage)&#10;      System.exit(1)  // Ensure container restarts on fatal errors&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>